### All of the processing (e.g. Retention Time Factor sorting, linear problem solving)
### followed by the 
### View Data Function in shiny
### February 20, 2019


RT_Factor_Sort <- function(original_data, RT_Factor_Dbase){
  
  ### Check Inputs ###
  
  if (is.null(RT_Factor_Dbase$Mean_DNPPE_Factor)) {
    
    stop("Looks like input 'RT_Factor_Dbase' is not the right one.\n", 
         "Make sure you're using an up to date database with",
         "a Mean DNPPE Factor for each compound.")
    
  }
  if (is.null(LOBpeaklist$match_ID)) {
    
    stop("Input data.frame does not contain a 'match_ID' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$compound_name)) {
    
    stop("Input data.frame does not contain a 'compound_name' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$LOBdbase_mz)) {
    
    stop("Input data.frame does not contain a 'LOBdbase_mz' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$peakgroup_rt)) {
    
    stop("Input data.frame does not contain a 'peakgroup_rt' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$FA_total_no_C)) {
    
    stop("Input data.frame does not contain a 'FA_total_no_C' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$FA_total_no_DB)) {
    
    stop("Input data.frame does not contain a 'FA_total_no_DB' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$FA_total_no_DB)) {
    
    stop("Input data.frame does not contain a 'FA_total_no_DB' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  # make sure peakgroup rt is numeric
  original_data$peakgroup_rt <- as.numeric(original_data$peakgroup_rt)
  
  #check if there is an X1 or X0 column, and get rid of it
  if(is.null(original_data$X0) != FALSE){
    original_data <- original_data %>% select(-X0)
  }
  if(is.null(original_data$X1) != FALSE){
    original_data <- original_data %>% select(-X0)
  }
  
  # Extract correct DNPPE retention time
  DNPPE_RT <- original_data$peakgroup_rt[which(grepl("DNPPE", original_data$compound_name))]
  #DNPPE_RT <- DNPPE_RT[***]  #if there are two DNPPE peaks, index to the correct one
  
  # Add column for DNPPE factor and an empty one for flagging
  original_data <- original_data %>% 
    mutate(DNPPE_Factor = peakgroup_rt/DNPPE_RT, Flag = "None") %>% 
    filter(species != "NA") 
  
  # isolate major intact polar lipid classes, unoxidized (need to add pigments, etc.)         
  Main_Lipids <- original_data %>%
    filter(degree_oxidation == "0", 
           species == "BLL"| 
             species == "DGCC" |
             species == "DGTS_DGTA" |
             species == "PE" |
             species == "PG" |
             species == "PC" |
             species == "MGDG" |
             species == "DGDG" |
             species == "SQDG"|
             species == "TAG"|
             species == "DAG"|
             species == "FFA")
  
  # isolate oxidized lipids into df
  Ox_Lipids <- original_data %>% 
    filter(degree_oxidation > 0)
  
  # flag known vs unknown by checking whether grepl returns anything in the database
  for (i in 1:length(Main_Lipids$compound_name)){
    which_row <- which(grepl(paste0("^", Main_Lipids$compound_name[i], "$"), RT_Factor_Dbase$compound_name))
    
    if(is.na(RT_Factor_Dbase$Mean_DNPPE_Factor[which_row]) != TRUE ){
      Main_Lipids$Flag[i] = "Known"
    }else{
      Main_Lipids$Flag[i] = "Unknown"
    }
    
  }
  
  # separate into two dfs
  Known_RtFs <- Main_Lipids %>% filter(Flag == "Known")
  Unknown_RtFs <- Main_Lipids %>% filter(Flag == "Unknown")
  
  # for each compound in the "Known" df, grab its corresponding row number in RT_Factor_Dbase,
  # then flag it as follows
  # first check if it's in a 10% 
  
  for (i in 1:length(Known_RtFs$compound_name)){
    which_row <- as.numeric(which(grepl(paste0("^", Known_RtFs$compound_name[i], "$"), RT_Factor_Dbase$compound_name)))
    
    if(Known_RtFs$DNPPE_Factor[i] < (RT_Factor_Dbase$Mean_DNPPE_Factor[which_row]*1.1) & Known_RtFs$DNPPE_Factor[i] > (RT_Factor_Dbase$Mean_DNPPE_Factor[which_row]*0.9)){
      if(Known_RtFs$DNPPE_Factor[i] < (RT_Factor_Dbase$Mean_DNPPE_Factor[which_row]*1.05) & Known_RtFs$DNPPE_Factor[i] > (RT_Factor_Dbase$Mean_DNPPE_Factor[which_row]*0.95)){
        if(RT_Factor_Dbase$ms2_verified[which_row] == "Yes"){
          Known_RtFs$Flag[i] = "ms2v"
        }else{
          Known_RtFs$Flag[i] = "5%_rtv"
        }
      }else{
        (Known_RtFs$Flag[i] = "10%_rtv")
      }
    }else{
      Known_RtFs$Flag[i] = "Red"
    }
  }
  
  
  
  # combine known and unknown dfs
  Combined <- rbind(Known_RtFs, Unknown_RtFs)
  
  # change levels of colors so they plot in the right order
  Combined$Flag = factor(Combined$Flag, levels = c("Red", "ms2v", "5%_rtv", "10%_rtv", "Unknown"))
  
  return(Combined)
}

LOB_lpsolve <- function(LOBpeaklist,choose_class=NULL,use_ms2_RtF) {
  
  library(lpSolve)
  library(ggplot2)
  
  ### Check Inputs ###
  
  if (!class(LOBpeaklist)=="data.frame") {
    
    stop("Input 'LOBpeaklist' is not an 'data.frame' object.\n", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$match_ID)) {
    
    stop("Input data.frame does not contain a 'match_ID' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$compound_name)) {
    
    stop("Input data.frame does not contain a 'compound_name' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$LOBdbase_mz)) {
    
    stop("Input data.frame does not contain a 'LOBdbase_mz' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$peakgroup_rt)) {
    
    stop("Input data.frame does not contain a 'peakgroup_rt' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$FA_total_no_C)) {
    
    stop("Input data.frame does not contain a 'FA_total_no_C' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  if (is.null(LOBpeaklist$FA_total_no_DB)) {
    
    stop("Input data.frame does not contain a 'FA_total_no_DB' column.", 
         "Please use a data.frame generated by 'getLOBpeaklist'.")
    
  }
  
  ### Format our input in a 'run' dataframe
  return <- LOBpeaklist
  LOBpeaklist <- LOBpeaklist[which(LOBpeaklist$degree_oxidation==0),]
  
  if (is.null(choose_class)==FALSE) {
    if(choose_class%in%unique(LOBpeaklist$species)==FALSE){
      stop("Chosen 'choose_class' does not appear in the 'species' column of data.frame.")
    }else{
      LOBpeaklist <- LOBpeaklist[which(LOBpeaklist$species==choose_class),]}
  }else{
    LOBpeaklist <- subset(LOBpeaklist, subset = lipid_class %in% c("IP_DAG","IP_MAG","TAG"))
  }
  # Put what we need in a dataframe 
  PRErun  <- data.frame(LOBpeaklist$match_ID,
                        LOBpeaklist$compound_name,
                        LOBpeaklist$LOBdbase_mz,
                        LOBpeaklist$peakgroup_rt,
                        LOBpeaklist$FA_total_no_C,
                        LOBpeaklist$FA_total_no_DB,
                        LOBpeaklist$species)
  
  #Re-name our column names
  colnames(PRErun) <- c("match_ID",
                        "compound_name",
                        "LOBdbase_mz",
                        "peakgroup_rt",
                        "FA_total_no_C",
                        "FA_total_no_DB",
                        "species")
  
  ### Begin Screening
  
  for (k in 1:length(unique(PRErun$species))) {
    
    run <- PRErun[which(PRErun$species== unique(PRErun$species)[k]),]
    
    #Binary string for each point
    Binary_String <- rep(1, nrow(run)) 
    
    #Empty String we will build a restrictions from
    Empty_String <- rep(0, nrow(run)) 
    
    #Matrix of our Exclusions
    Exclusion_Matrix <- matrix(nrow = 1,ncol = nrow(run))
    
    # Run a loop to find what to exclude for each point
    for (i in 1:nrow(run)) {
      
      #Get our row
      subject <- run[i,]
      
      # Make a table to store our exclusion info
      Exclusion_Table <- run
      Exclusion_Table$Exclude <- rep(FALSE,nrow(run))
      
      #Lets sort the compounds run above and below our point in terms of rt
      lower_rt <- run[which(run$peakgroup_rt < subject$peakgroup_rt),]
      higher_rt <- run[which(run$peakgroup_rt > subject$peakgroup_rt),]
      
      #Now find ones that break the rules for lower and higher and set Exclude to TRUE in the Exclusion_Table
      
      #Exclude the lower
      lower_names <- row.names(lower_rt[lower_rt$FA_total_no_C>=subject$FA_total_no_C & lower_rt$FA_total_no_DB<=subject$FA_total_no_DB,])
      Exclusion_Table[lower_names,"Exclude"] <- TRUE
      #Exclude the higher
      higher_names <- row.names(higher_rt[higher_rt$FA_total_no_C<=subject$FA_total_no_C & higher_rt$FA_total_no_DB>=subject$FA_total_no_DB,])
      Exclusion_Table[higher_names,"Exclude"] <- TRUE
      #Exclude the compounds with the same name
      Exclusion_Table[which(Exclusion_Table$compound_name==subject$compound_name),"Exclude"] <- TRUE
      
      Exclusion_String <- Empty_String
      
      for (j in 1:nrow(run)) {
        if(j!=i){
          if(Exclusion_Table[j,"Exclude"]==TRUE){
            Exclusion_String <- Empty_String
            Exclusion_String[j]<-1
            Exclusion_String[i]<-1
            Exclusion_Matrix <- rbind(Exclusion_Matrix,Exclusion_String)
            rownames(Exclusion_Matrix) <- NULL
            Exclusion_Matrix <- unique(Exclusion_Matrix)
          }
        }
        cat("\r")
        flush.console()
        cat("Writing rules for",as.character(unique(PRErun$species)[k]),"compound number",i,"of",nrow(run),". Number of Rules created:",nrow(Exclusion_Matrix),"...")
      }
    }
    cat(" Done")
    Final_Exclusion_Matrix <- Exclusion_Matrix[-1,]
    
    if(is.null(nrow(Final_Exclusion_Matrix))){
      cat("\nCompound class to small or any lacks noise to screen.")
    }else{
      
      #time to screen
      dir <- rep("<=", nrow(Final_Exclusion_Matrix)) # all constraints '<='
      
      rhs <- rep(1, nrow(Final_Exclusion_Matrix)) # all right hand sides = 1
      
      #all.bin for binary. Set Solution number high to get all solutions.
      
      
      cat("\nApplying lpSolve algorythm...")
      sol <- lpSolve::lp("max", Binary_String, Final_Exclusion_Matrix, dir, rhs,all.bin = TRUE,num.bin.solns = 100) 
      cat(" Done")
      numcols <- nrow(run)
      numsols <- sol$num.bin.solns
      
      solutions <- matrix(head(sol$solution, numcols*numsols), nrow=numsols, byrow=TRUE)
      
      run$Picked <- solutions[1,]
      FINAL <-run[which(run$Picked==1),]
      
      bar <- data.frame(colSums(solutions))
      run$Type<-rep(0,nrow(run))
      run[which(bar==0),"Type"] <- 'No'
      run[which(bar!=nrow(solutions) & bar!=0 ),"Type"] <- 'Maybe'
      run[which(bar==nrow(solutions)),"Type"] <- 'Yes'
      
      print(ggplot(run,aes(x = peakgroup_rt, y = LOBdbase_mz,color=Type)) +
              scale_color_manual(values=c("#e7cd08", "#e70808", "#08e799")) +
              geom_point() +
              geom_text(label=as.character(run$compound_name),nudge_y = 10,size=2,color="black")+
              ggtitle("lpSolve Screened Data") +
              xlab("Peak Group Retention Time (sec)")+
              ylab("Peak Group m/z")
      )
      
      return[return$match_ID %in% run$match_ID,"lpSolve"] <- run$Type
    }
  }
  return(return)
}

LOB_viewdata <- function(LOBpeaklist, RT_Factor_Dbase){
  
  #Make sure we have our librarys loaded 
  library(shiny)
  library(tidyverse)
  library(RColorBrewer)
  
  #Rename our peak list so we can modify it and keep the complete one
  run <- LOBpeaklist
  tidy_run <- run %>% 
    gather(key = Sample_ID,
           value = Peak_Size,
           -species, -compound_name, -LOBdbase_mz,
           -peakgroup_rt, -degree_oxidation,
           -FA_total_no_C, -FA_total_no_DB)
  
  # Set up our large color pallete
  palette <-c("#E41A1C","#377EB8","#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF",
              "#999999", "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628",
              "#F781BF", "#999999", "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33",
              "#A65628", "#F781BF", "#999999", "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00",
              "#FFFF33", "#A65628", "#F781BF", "#999999", "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3",
              "#FF7F00", "#FFFF33", "#A65628", "#F781BF", "#999999", "#E41A1C", "#377EB8", "#4DAF4A",
              "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF", "#999999", "#E41A1C", "#377EB8",
              "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF", "#999999", "#E41A1C",
              "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF", "#999999",
              "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF",
              "#999999", "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628",
              "#F781BF", "#999999", "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33",
              "#A65628", "#F781BF", "#999999")
  
  # Define the app
  app=shinyApp(
    
    ui = fluidPage(
      
      title = "Lipid Data Viewer",
      
      
      tabsetPanel(
        tabPanel(
          plotOutput('plot'),
          title = "M/Z vs RT",
                 column(3,
                        h4("Lipid Data Viewer"),
                        sliderInput('rt', 'X-Axis Limits (Retention Time)', 
                                    min=floor(min(run$peakgroup_rt)), 
                                    max=ceiling(max(run$peakgroup_rt)),
                                    value = c(floor(min(run$peakgroup_rt)),ceiling(max(run$peakgroup_rt))), 
                                    step=10, round=1),
                        sliderInput('mz', 'Y-Axis Limits (m/z)', 
                                    min=floor(min(run$LOBdbase_mz)), 
                                    max=ceiling(max(run$LOBdbase_mz)),
                                    value = c(floor(min(run$LOBdbase_mz)),ceiling(max(run$LOBdbase_mz))), 
                                    step=10, round=1),
                        br(),
                        checkboxInput('text', 'Display Names'),
                        checkboxInput('oxy', 'Toggle Oxidized Compounds ')
                 ),
                 column(4,
                        selectInput('class', 'Select Lipid Class', c("All",as.character(unique(run$species))),multiple = TRUE,selected = "All"),
                        selectInput('color', 'Point Color', c('None','Carbon','Double Bonds','lpSolve Fitted', 'RT_Window', 'Lipid Class')),
                        selectInput('color', 'Color', c('None', names(run)))
                 ),
                 column(4,
                        selectInput('facet_row', 'Facet Row', c(None='.', names(run))),
                        selectInput('facet_col', 'Facet Column', c(None='.', names(run)))
                 )
        ),
        
        tabPanel(
          plotOutput('bar'),
          title = "Distributions",
                column(4,
                       selectInput('species', 'Select Species', c("All",as.character(unique(run$species))),multiple = FALSE),
                       selectInput('xaxis', 'X_Variable', c('None','Carbon','Double Bonds','lpSolve Fitted','Lipid Class'), selected = 'Carbon'),
                       selectInput('fill_colors', 'Fill_Colors', c('Carbon', 'Double Bonds', 'Species'))
          
          
          )
        )
      )
    ),
    
    
    # Define server logic to draw our plot
    server = function(input, output) {
      
      # Will update as varibles change
      output$plot <- renderPlot({
        
        data <- run #so we dont change our intial data 
        
        # To plot all data
        if("All"%in%input$class!=TRUE){
          data <- data[data$species==input$class,]
        }
        
        # To elimate oxy compounds if desired 
        if(input$oxy){
          data <- data[data$degree_oxidation=="0",]
        }
        
        # Construct inital plot with limits and points
        g <- ggplot(data = data,mapping = aes(x = peakgroup_rt, y = LOBdbase_mz)) +
          geom_point() +
          xlim(c(input$rt[1],input$rt[2])) +
          ylim(c(input$mz[1],input$mz[2]))+
          xlab("Retention Time (sec)") +
          ylab("m/z")
        
        # Add colors for carbon number
        if(input$color=="Carbon"){
          g <- g + geom_point(aes(color=as.character(FA_total_no_C))) +
            scale_color_manual(values = palette)
          
        }
        
        # Add color for DB number 
        if(input$color=="Double Bonds"){
          g <- g + geom_point(aes(color=as.character(FA_total_no_DB))) +
            scale_color_manual(values = palette)
        }
        
        
        
        # Add colors for lpSolve solutions
        if(input$color=="lpSolve Fitted"){
          g <- g + geom_point(aes(color=as.character(lpSolve))) +
            scale_color_manual(values = c("#E8DA1E","#FF3030","#B6EEA6"))
        }
        
        if(input$color=="RT_Window"){
          g <- g + 
            geom_point(aes(color=as.character(Flag))) +
              scale_color_manual(values = c("#00FF00", "#545454","#E8DA1E","#FF3030", "#0000FF"))
        }
        
        if(input$facet_row == "RTF_Window"){
          g <- g + geom_errorbarh(aes(xmax = as.numeric(RTF_Window/DNPPE_Factor*peakgroup_rt*1.1), xmin = RTF_Window/DNPPE_Factor*peakgroup_rt*0.9, color=as.character(Flag)))
        }
        
        # Add colors for classes
        if(input$color=="Lipid Class"){
          g <- g + geom_point(aes(color=as.character(species))) +
            scale_color_manual(values = palette)
        }
        
        # Add compound names 
        if (input$text){
          g <- g + geom_text(aes(label=compound_name),nudge_y = 5,size=2)
        }
        
        print(g)
        
      })
      
      output$bar <- renderPlot({
        
        tidy_data <- tidy_run %>% 
          filter(is.na(FA_total_no_C) != TRUE)
        tidy_data <- tidy_data[tidy_data$species==input$species,]
        
        
        # if("All"%in%input$species!=TRUE){
        #   tidy_data <- tidy_data[tidy_data$species==input$species,]
        # }
        
        # To elimate oxy compounds if desired 
        # if(input$oxy){
        #   tidy_data <- tidy_data[tidy_data$degree_oxidation=="0",]
        # }
        
        # Construct inital plot with limits and points
        b <- ggplot(data = tidy_data, aes(x = FA_total_no_C,y = Peak_Size))+
          geom_bar(stat = "identity", position = "stack") +
          scale_color_manual(values = palette)+# Add colors for carbon number
          xlab("as.character(input$xaxis)") +
          ylab("Peak Size")+ 
          theme(
            axis.text.x = element_blank(),
            axis.text.y = element_blank(),
            axis.ticks = element_blank())
        
        if(input$xaxis=="Carbon"){
          b <- ggplot(data = tidy_data, aes(FA_total_no_C,y = Peak_Size)) +
            geom_bar(stat = "identity", position = "stack") +
            scale_color_manual(values = palette)+
            xlab(paste(input$xaxis)) +
            ylab("Peak Size")# Add colors for carbon number

        }

        # Add color for DB number
        if(input$xaxis=="Double Bonds"){
          b <- ggplot(data = tidy_data, aes(FA_total_no_DB, y = Peak_Size)) +
            geom_bar(stat = "identity", position = "stack") +
            scale_color_manual(values = palette)+
            xlab(paste(input$xaxis)) +
            ylab("Peak Size")# Add colors for carbon number
        }
        
        # Add colors
        if(input$fill_colors=="Double Bonds"){
          b <- b + geom_point(aes(fill=FA_total_no_DB)) +
            scale_color_manual(values = palette)
        }
        print(b)
      })
    }
  )
  runApp(app)
}

LOB_viewdata(Combined)

original_data <- read.csv("C:/Users/TSQ/Desktop/Daniel Lowenstein/Older_Projects/Bowman/Bowman_LOBSTAHS_screened_peakdata_2018-11-30T4-42-32_PM-0500.csv")
